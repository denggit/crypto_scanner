# Volatility Compression Breakout（VCB）策略完整说明文档

> 适用场景：**高频 / 亚秒级不做，偏 1m–5m 短线自动化交易**
> 目标：**在 300+ 币种中，用高确定性的“波动率压缩 → 爆发”结构捕捉非对称收益**

---

## 一、策略的核心逻辑（先给结论）

这套策略不是在**预测方向**，而是在**等待结构性失衡**。

**一句话版本：**

> 当一个币种在短周期内出现 *真实波动率显著低于中周期背景波动率*，并且价格被“压”在狭窄区间内 → 只要价格脱离这个区间，行情往往不是 0.2%，而是 1%–3% 的连续运动。

所以策略分为三件事：

1. **如何判定“真的在压缩”**（而不是假平静）
2. **压缩后是否还“新鲜”**（避免等到失效）
3. **什么时候算突破，立刻执行**

---

## 二、压缩的“确定性”判定方法（核心）

### 2.1 为什么不用单一指标

| 方法      | 问题                   |
| ------- | -------------------- |
| 只用 ATR  | 会被整体降波动市场骗（ATR 一起下降） |
| 只用布林带   | 对不同价格尺度、不同币种不稳定      |
| 只排序 CVI | 无时间结构，容易陈旧           |

**结论：压缩一定要是“相对压缩”，而不是“绝对变小”**。

---

## 三、推荐的压缩判定（实盘可用版本）

### 3.1 ATR 相对收缩（主条件）

**K 线周期：1 分钟**

* `ATR_short = ATR(10)`
* `ATR_mid   = ATR(60)`

判定条件：

```
ATR_short < 0.5 × ATR_mid
```

含义：

* 短期真实波动率显著低于中期背景
* 不是整体市场冷，而是**被压住**

> ⚠️ 经验值：0.45–0.6 都可，0.5 是稳定起点

---

### 3.2 布林带宽度收缩（确认条件）

* 布林带参数：`BB(20, 2)`
* 计算带宽：

```
BB_width = (Upper - Lower) / Middle
```

判定方式（两种任选其一）：

**方式 A（阈值法）**

```
BB_width < 过去 N 根的 20% 分位
```

**方式 B（相对收缩）**

```
BB_width < 0.7 × BB_width_60_mean
```

> 推荐：**ATR 是主，BB 是过滤器**

---

### 3.3 最终压缩判定公式

```
IS_COMPRESSION =
    ATR(10) < 0.5 × ATR(60)
AND
    BB_width 显著收缩
```

只有两个都满足，才认为是**有效压缩**。

---

## 四、为什么不用一直“死盯”压缩币？（你提的关键问题）

### 4.1 压缩是“状态”，不是“标签”

你说得完全对：

> 如果 ATR(60) 一直下降，最后 ATR(10) 和 ATR(60) 会趋同，那压缩就失效了。

所以：

**压缩必须有“新鲜度”约束**。

---

### 4.2 压缩的生命周期设计（非常重要）

给每个币种一个压缩事件：

```text
Compression Event
├── start_time
├── atr_ratio = ATR(10)/ATR(60)
├── bb_width_zscore
├── ttl（有效期）
```

#### TTL（Time To Live）建议：

| 周期 | TTL         |
| -- | ----------- |
| 1m | 20–40 根 K 线 |
| 5m | 8–15 根 K 线  |

规则：

* 超过 TTL **未突破 → 丢弃**
* ATR_ratio 回升（>0.7）→ 丢弃

> ❗ 这是防止“假压缩”和“陈旧压缩”的关键

---

## 五、突破的执行逻辑（不要再看 ATR 了）

### 5.1 角色分工要明确

* **ATR / BB**：只用于 *识别是否值得监控*
* **突破执行**：只看价格行为

ATR 不参与下单判断。

---

### 5.2 突破定义（实盘友好）

**做多突破：**

```
Close > BB_upper
AND
Volume > MA(Volume, 20)
```

**做空突破：**

```
Close < BB_lower
AND
Volume > MA(Volume, 20)
```

> 成交量过滤非常重要，能砍掉大量假突破

---

### 5.3 下单方式

* **市价 / aggressive 限价**
* 不等回踩（回踩是另一套策略）

---

## 六、完整系统架构（你描述的生产者 / 消费者是对的）

### 6.1 模块划分

```
[Market Data]
      ↓
[Compression Scanner]  ←（生产者）
      ↓
[Compression Pool (TTL)]
      ↓
[Breakout Watcher]     ←（消费者）
      ↓
[Order Executor]
      ↓
[Risk Manager]
```

---

### 6.2 Compression Scanner（生产者）

* 扫描 300+ 币种
* 只做一件事：

```text
发现“新压缩” → 放入 Pool
```

---

### 6.3 Compression Pool（中间态）

* 每个币种最多一个压缩事件
* 定期清理：

  * TTL 到期
  * ATR_ratio 失效

---

### 6.4 Breakout Watcher（消费者）

* 只盯 Pool 里的币
* 高频检查（每根 K 或 tick）
* 一旦突破 → 发信号 → 删除事件

---

## 七、风险控制（别忽略）

### 7.1 止损

推荐：

```
SL = max(
    压缩区间另一侧,
    0.8 × ATR(60)
)
```

### 7.2 止盈

两种：

* 固定 R：`TP = 1.5R – 2.5R`
* 或 ATR 跟踪止盈

---

## 八、这套策略的真实优缺点（实话）

### 优点

* **确定性来自结构，不是参数拟合**
* 对币种无偏见，天然适合多币扫描
* 非常适合自动化

### 缺点

* 突破有时很快，吃滑点
* 震荡市会有假突破（靠 volume + TTL 控制）
* 不适合低流动性币

---

## 九、一句话总结

> **VCB 本质不是找机会，而是过滤时间。**
> 绝大多数时间不交易，只在“波动率被压到不合理低位”的那一小段时间，赌结构回归。

如果你愿意，下一步我可以直接帮你把：

* **参数区间做成可回测版本**
* **或者给你一份 Python 伪代码 / 模块接口设计**
