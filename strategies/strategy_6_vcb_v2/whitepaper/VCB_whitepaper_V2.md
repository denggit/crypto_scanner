# Volatility Compression Breakout（VCB）策略白皮书 V2.0

> 基于 V1.0 实盘反馈的结构化优化版本  
> 适用场景：1m–5m 短线自动化交易（加密货币）  
> 核心目标：**降低假突破率、减少过度交易、提升胜率至 45%+，长期期望值为正**

---

## 0. 修订说明（V2.0 的定位）

V2.0 并非推翻原策略，而是一次**工程级纠偏**：

* ❌ 修正 V1.0 中“压缩过宽、突破过急、止损过敏”的问题
* ✅ 保留 **VCB 的核心哲学**：

  > *波动率极度压缩 → 结构失衡 → 趋势级别的瞬时释放*

V2.0 的核心思想只有一句话：

> **不是“看见压缩就赌突破”，而是只交易“质量足够高、值得下注的压缩”。**

---

## 一、策略总览（不变）

### 1.1 策略核心逻辑

1. 市场经历一段 **多维度波动率压缩**
2. 压缩形成明确的价格区间（结构）
3. 某一方向出现 **高质量突破**
4. 波动率从“压缩态”切换至“扩张态”
5. 捕捉扩张初期的方向性收益

VCB 是一个：

* **事件驱动型** 策略
* **低频 + 高赔率** 结构
* **明确失败条件** 的非均值策略

---

## 二、压缩判定系统（V2.0 核心升级）

### 2.1 多时间框架结构（新增）

V2.0 不再允许单一时间框架直接触发交易。

```
Level 1：5m —— 主压缩识别（结构层）
Level 2：15m —— 背景验证（是否真的是“蓄势”）
Level 3：1m —— 入场与执行（时机层）
```

**硬性约束**：

* 只有在 **5m 出现压缩结构** 的前提下，1m 的信号才有意义

---

### 2.2 压缩评分系统（替换原二元判断）

V1.0 的问题本质是：

> **把“轻度收缩”和“极限压缩”一视同仁**

V2.0 引入 **Compression Score（0–100）**，只交易高质量压缩。

#### 评分维度与权重

| 维度       | 权重  | 含义            |
| -------- | --- | ------------- |
| ATR 相对压缩 | 30% | 短期波动率 vs 中期基准 |
| 压缩持续时间   | 25% | 是否有足够“蓄力”     |
| 成交量健康度   | 20% | 是否处于“等待而非出货”  |
| 价格区间收敛   | 15% | 高低点是否明显收窄     |
| 均线聚合度    | 10% | 市场是否进入共识冻结态   |

#### 判定规则

```python
compression_score = calc_compression_score()
IS_COMPRESSION = compression_score >= 70
```

**工程原则**：

* 70 分以下的压缩 **全部忽略**
* 80+ 才是策略最理想形态

---

### 2.3 压缩事件结构（V2.0）

```python
CompressionEventV2 = {
    symbol,
    timeframe: "5m",
               compression_score,
               compression_range: [low, high],
start_time,
metrics: {
    atr_ratio,
    duration_bars,
    volume_health,
    range_contraction,
    ma_convergence
},
breakout_levels: {
    up: high * 1.01,
    down: low * 0.99
},
invalidation_levels: {
    up: high * 1.03,
    down: low * 0.97
}
}
```

#### TTL 规则（保留 + 增强）

* 超过 N 根 K 线未突破 → 失效
* compression_score ↓ 到 60 以下 → 立即移除
* 价格脱离区间但未形成突破 → 判为“结构损坏”

---

## 三、突破执行逻辑（V2.0）

### 3.1 三重突破过滤机制（新增）

#### 第一层：价格 + 放量（必要条件）

* 有效突破幅度：**≥ 压缩区间的 1%**
* 成交量：≥ 1.5 × 20 均量

---

#### 第二层：突破质量过滤（核心）

突破 K 线必须满足以下条件中的 **至少 3 条**：

* 实体 ≥ 0.4 × ATR(14)
* 影线短（假突破过滤，影线<30%实体）
* 成交量显著高于近期低点
* 创局部新高 / 新低（动量）

> **目的只有一个**：
> 排除“被扫流动性”的突破。

---

#### 第三层：延迟确认（反噪声）

* 入场后观察 **1–2 根 K 线**
* 不允许价格重新回到突破边界内
* 成交量不能快速塌缩

这是 V2.0 对“刚突破就反向”的核心修复。

---

## 四、仓位与执行（轻微调整）

* 仍然采用 **一次性建仓**（不加仓）
* 仓位大小由账户风控模块统一管理
* 同一 symbol 同方向 **禁止重复入场**

---

## 五、平仓与风险管理（重点升级）

### 5.1 初始止损（结构优先）

止损 = **结构止损** 与 **ATR 动态止损** 中更保守者

```python
SL = max(struct_stop, atr_stop)  # 多头
SL = min(struct_stop, atr_stop)  # 空头
```

* 结构止损：压缩区间反侧 ± 0.2×ATR
* ATR 止损：1.2 × ATR(20)

> V2.0 明确：
> **只要价格重新回到压缩结构内部，策略逻辑已被否定。**

---

### 5.2 动态止损与保本规则

* 浮盈 ≥ 0.5R → SL 移至 Entry（防回撤）
* 浮盈 ≥ 1R → 启用 ATR 跟踪止损
* 趋势明确 → 可切换趋势线止损

---

### 5.3 止盈策略（多目标）

#### 主流币（BTC / ETH / SOL）

* 1.5R：40% 平仓
* 2.5R：30% 平仓
* 剩余 30%：移动止损持有

#### 山寨币

* 2R：60% 平仓
* 3R：40% 平仓

---

## 六、结构失败判定（防止慢性流血）

任意满足以下 **两个条件**，判定失败：

1. 价格回到压缩区间
2. 成交量断崖式下降
3. 出现强反向实体 K 线

失败处理：

```
第一次 → 警告
连续出现 → 全部平仓
```

---

## 七、系统架构（微调）

### 7.1 Producer

```
Market Data
 → Multi-TF Analyzer
 → Compression Scorer
 → Quality Filter
 → Compression Pool
```

### 7.2 Consumer

```
Compression Pool
 → Breakout Watcher
 → Quality Confirmer
 → Entry Executor
 → Structure Validator
 → Position Manager
```

---

## 八、V2.0 的真实预期

| 指标     | V1.0 | V2.0 目标 |
| ------ | ---- | ------- |
| 胜率     | ~30% | 45%+    |
| 假突破率   | 高    | 明显下降    |
| 交易频率   | 过高   | ↓ 50%   |
| 单日最大亏损 | 20%  | <5%     |

---

## 九、结语（非常重要）

V2.0 的核心不是“更聪明”，而是：

> **更克制、更慢、更少出手。**

VCB 不是一个“天天交易”的策略，
它是一个：

* **等结构成熟**
* **只在值得下注的时候出手**
* **其余时间什么都不做**

的策略。

这正是它能长期存活的前提。


## 十、 附录

### 多时间框架压缩判断框架（开发规范）

#### 一、三个时间周期的具体职责与参数

##### **Level 1 - 主周期（5分钟）：压缩结构识别**
```
作用：核心压缩判断，决定是否加入监控池
数据：5分钟K线
历史数据需求：至少200根K线（约17小时）
```

#### **具体判断指标与阈值：**

**1. ATR相对压缩（主条件）**
```python
# 计算
ATR_short_5m = ATR(5分钟K线, 周期=20)    # 最近100分钟波动率
ATR_mid_5m = ATR(5分钟K线, 周期=100)     # 最近500分钟波动率
ATR_ratio_5m = ATR_short_5m / ATR_mid_5m

# 阈值
if ATR_ratio_5m < 0.45:          # 强烈压缩
    atr_score = 3
elif ATR_ratio_5m < 0.55:        # 中等压缩  
    atr_score = 2
else:
    atr_score = 0
```

**2. 布林带宽度百分位（辅助条件）**
```python
# 计算布林带宽度
BB_width_5m = (布林上轨 - 布林下轨) / 布林中轨 * 100

# 计算历史百分位（过去100根K线）
BB_width_history = 过去100根5分钟K线的BB_width数组
current_percentile = 计算百分位(BB_width_5m, BB_width_history)

# 阈值
if current_percentile < 20:      # 宽度处于历史最低20%
    bb_score = 3
elif current_percentile < 30:    # 宽度处于历史最低30%
    bb_score = 2
else:
    bb_score = 0
```

**3. 价格区间收缩（辅助条件）**
```python
# 计算近期价格范围
近期高点 = MAX(最高价, 周期=10)    # 最近50分钟高点
近期低点 = MIN(最低价, 周期=10)    # 最近50分钟低点
近期范围 = 近期高点 - 近期低点

# 计算中期价格范围
中期高点 = MAX(最高价, 周期=50)    # 最近250分钟高点
中期低点 = MIN(最低价, 周期=50)    # 最近250分钟低点
中期范围 = 中期高点 - 中期低点

范围比率 = 近期范围 / 中期范围

# 阈值
if 范围比率 < 0.5:      # 收缩超过50%
    range_score = 3
elif 范围比率 < 0.65:   # 收缩35-50%
    range_score = 2
else:
    range_score = 0
```

**4. 持续时间要求（必须条件）**
```python
# 需要压缩持续一定时间
压缩持续K线数 = 连续满足以下条件的天数：
1. 价格振幅(高-低)/开盘价 < 0.5%
2. 成交量比率(当前/20周期均量) < 1.5

# 阈值
if 压缩持续K线数 >= 6:      # 至少30分钟
    duration_score = 2
elif 压缩持续K线数 >= 4:    # 至少20分钟
    duration_score = 1
else:
    duration_score = 0
```

**5. 成交量健康度（必须条件）**
```python
# 计算成交量比率
成交量比率 = MA(成交量, 5) / MA(成交量, 20)

# 阈值
if 0.7 < 成交量比率 < 1.3:   # 成交量平稳
    volume_score = 2
else:
    volume_score = 0
```

#### **5分钟周期压缩判定逻辑：**
```python
# 综合评分（满分13分）
compression_score_5m = atr_score + bb_score + range_score + duration_score + volume_score

# 判定条件
is_compressed_5m = (compression_score_5m >= 8) and (duration_score > 0) and (volume_score > 0)

# 如果判定为压缩，记录压缩区间
if is_compressed_5m:
    压缩区间上轨 = MAX(最高价, 周期=10)
    压缩区间下轨 = MIN(最低价, 周期=10)
    压缩中心线 = (压缩区间上轨 + 压缩区间下轨) / 2
```

---

#### **Level 2 - 确认周期（15分钟）：压缩有效性验证**
```
作用：确认压缩不是短期偶然，排除趋势中的假压缩
数据：15分钟K线
历史数据需求：至少100根K线（约25小时）
```

#### **具体验证指标：**

**1. 趋势方向确认**
```python
# 检查15分钟线是否有明显趋势
MA20_15m = MA(收盘价, 周期=20)    # 5小时均线
MA50_15m = MA(收盘价, 周期=50)    # 12.5小时均线

# 判断趋势强度
价格偏离度 = abs(收盘价 - MA20_15m) / MA20_15m * 100
趋势方向 = "上涨" if 收盘价 > MA20_15m else "下跌"

# 趋势过滤条件
if 价格偏离度 > 2.0:        # 价格偏离均线超过2%
    趋势过强 = True
else:
    趋势过强 = False
```

**2. 波动率背景确认**
```python
# 检查15分钟线整体波动率
ATR_15m = ATR(15分钟K线, 周期=14)   # 最近3.5小时ATR
ATR_相对水平 = ATR_15m / 收盘价 * 100

# 阈值
if ATR_相对水平 > 1.5:      # 整体波动率过高，不适合压缩突破
    波动率过高 = True
else:
    波动率过高 = False
```

**3. 价格结构确认**
```python
# 检查15分钟线是否支持压缩结构
# 最近5根15分钟K线（75分钟）的最大振幅
最近5根高点 = MAX(最高价, 周期=5)
最近5根低点 = MIN(最低价, 周期=5)
75分钟振幅 = (最近5根高点 - 最近5根低点) / 最近5根低点 * 100

# 与更长期振幅比较
最近20根高点 = MAX(最高价, 周期=20)
最近20根低点 = MIN(最低价, 周期=20)
5小时振幅 = (最近20根高点 - 最近20根低点) / 最近20根低点 * 100

振幅比率 = 75分钟振幅 / 5小时振幅

# 阈值
if 振幅比率 < 0.4:          # 近期振幅显著收缩
    结构支持压缩 = True
else:
    结构支持压缩 = False
```

#### **15分钟周期验证逻辑：**
```python
# 验证条件（全部需要满足）
validation_conditions = [
    not 趋势过强,          # 条件1：没有过强趋势
    not 波动率过高,        # 条件2：整体波动率不高
    结构支持压缩,          # 条件3：价格结构支持压缩
]

# 判定结果
is_validated_15m = all(validation_conditions)

# 如果验证通过，计算支持度评分
if is_validated_15m:
    # 支持度评分（0-100）
    support_score = 0
    
    # 趋势支持度（40分）
    if 价格偏离度 < 1.0:
        support_score += 40
    elif 价格偏离度 < 1.5:
        support_score += 30
    elif 价格偏离度 < 2.0:
        support_score += 20
    
    # 波动率支持度（30分）
    if ATR_相对水平 < 1.0:
        support_score += 30
    elif ATR_相对水平 < 1.3:
        support_score += 20
    elif ATR_相对水平 < 1.5:
        support_score += 10
    
    # 结构支持度（30分）
    if 振幅比率 < 0.3:
        support_score += 30
    elif 振幅比率 < 0.4:
        support_score += 20
    elif 振幅比率 < 0.5:
        support_score += 10
```

---

#### **Level 3 - 入场周期（1分钟）：精确入场时机**
```
作用：监控突破，执行精确入场
数据：1分钟K线
历史数据需求：至少60根K线（1小时）
```

#### **突破监控参数：**

**1. 突破阈值计算**
```python
# 基于5分钟周期确定的压缩区间
# 向上突破阈值：压缩区间上轨 × (1 + 突破幅度)
# 向下突破阈值：压缩区间下轨 × (1 - 突破幅度)

突破幅度 = 0.01  # 1%（可根据品种调整）

上突破阈值 = 压缩区间上轨 * (1 + 突破幅度)
下突破阈值 = 压缩区间下轨 * (1 - 突破幅度)

# 监控带（提前预警）
上预警阈值 = 压缩区间上轨 * (1 + 突破幅度 * 0.5)  # 0.5%
下预警阈值 = 压缩区间下轨 * (1 - 突破幅度 * 0.5)
```

**2. 突破质量判断**
```python
def check_breakout_quality(突破K线, direction):
    """
    突破K线质量评分（0-100分）
    """
    score = 0
    
    # 1. 实体强度（30分）
    实体大小 = abs(突破K线.收盘 - 突破K线.开盘)
    实体比率 = 实体大小 / 突破K线.开盘 * 100
    
    if 实体比率 > 0.3:          # 实体>0.3%
        score += 30
    elif 实体比率 > 0.2:        # 实体>0.2%
        score += 20
    elif 实体比率 > 0.1:        # 实体>0.1%
        score += 10
    
    # 2. 成交量爆发（30分）
    成交量比率 = 突破K线.成交量 / MA(成交量, 20)
    
    if 成交量比率 > 2.0:        # 成交量>2倍均量
        score += 30
    elif 成交量比率 > 1.5:      # 成交量>1.5倍均量
        score += 20
    elif 成交量比率 > 1.2:      # 成交量>1.2倍均量
        score += 10
    
    # 3. 影线控制（20分）
    if direction == "long":
        上影线比率 = (突破K线.最高 - max(突破K线.开盘, 突破K线.收盘)) / 实体大小
        if 上影线比率 < 0.3:    # 上影线<30%实体
            score += 20
        elif 上影线比率 < 0.5:  # 上影线<50%实体
            score += 10
    else:
        下影线比率 = (min(突破K线.开盘, 突破K线.收盘) - 突破K线.最低) / 实体大小
        if 下影线比率 < 0.3:    # 下影线<30%实体
            score += 20
        elif 下影线比率 < 0.5:  # 下影线<50%实体
            score += 10
    
    # 4. 突破确认（20分）
    # 检查突破是否在K线收盘时确立
    if direction == "long":
        if 突破K线.收盘 > 上突破阈值:
            score += 20
    else:
        if 突破K线.收盘 < 下突破阈值:
            score += 20
    
    return score
```

**3. 入场执行规则**
```python
def execute_entry(突破K线, direction, 突破质量分):
    """
    入场执行逻辑
    """
    entry_rules = []
    
    # 规则1：突破质量必须>60分
    entry_rules.append(突破质量分 >= 60)
    
    # 规则2：突破必须发生在K线结束时（避免盘中假突破）
    entry_rules.append(突破K线.is_closed == True)
    
    # 规则3：突破后价格需保持在外（下一根K线开盘）
    next_bar = 获取下一根K线()
    if direction == "long":
        entry_rules.append(next_bar.开盘 > 压缩区间上轨)
    else:
        entry_rules.append(next_bar.开盘 < 压缩区间下轨)
    
    # 规则4：市场流动性检查（买卖价差）
    买卖价差比率 = (卖一价 - 买一价) / 买一价 * 100
    entry_rules.append(买卖价差比率 < 0.1)  # 价差<0.1%
    
    # 如果所有规则满足，执行入场
    if all(entry_rules):
        return True, {
            "entry_price": next_bar.开盘,
            "direction": direction,
            "breakout_quality": 突破质量分,
            "timestamp": next_bar.timestamp
        }
    else:
        return False, "入场条件不满足"
```

#### 二、三周期协同工作流程

#### **完整判断流程：**
```
1. 【5分钟周期】每5分钟执行一次压缩扫描
   - 计算ATR比率、布林带宽度、价格范围、持续时间、成交量
   - 综合评分>=8分且持续时间>0且成交量>0 → 识别为压缩
   - 记录压缩区间和中心线

2. 【15分钟周期】对5分钟识别的压缩进行验证
   - 检查趋势强度（价格偏离度<2%）
   - 检查整体波动率（ATR相对水平<1.5%）
   - 检查价格结构（振幅比率<0.4）
   - 全部满足 → 验证通过
   - 计算支持度评分（0-100）

3. 【压缩池管理】将验证通过的压缩加入监控池
   - 压缩ID：{symbol}_{timestamp}
   - 压缩区间：[下轨, 上轨]
   - 压缩质量：5分钟评分 + 15分钟支持度
   - TTL：根据质量设置30-60分钟

4. 【1分钟周期】对池中每个压缩进行突破监控
   - 实时监控1分钟K线
   - 价格突破阈值（±1%）→ 触发突破检查
   - 检查突破质量（实体、成交量、影线、确认）
   - 质量分>=60 → 等待K线结束确认
   - 下一根K线开盘仍在区间外 → 执行入场

5. 【入场后】启动结构验证
   - 监控入场后2根1分钟K线
   - 检查是否回到压缩区间内
   - 检查成交量是否维持
   - 验证失败 → 减仓或止损
```

#### **数据结构定义（供开发参考）：**

```python
# 压缩事件结构
CompressionEvent = {
    "id": str,                     # 唯一标识
    "symbol": str,                 # 交易对
    "timeframe": "5m",            # 主周期
    "detected_time": timestamp,   # 识别时间
    "compression_range": {         # 压缩区间
        "upper": float,           # 上轨
        "lower": float,           # 下轨
        "center": float,          # 中心线
    },
    "quality_metrics": {           # 质量指标
        "score_5m": int,          # 5分钟评分(0-13)
        "support_15m": int,       # 15分钟支持度(0-100)
        "atr_ratio": float,       # ATR比率
        "duration_bars": int,     # 持续时间(K线数)
        "volume_health": float,   # 成交量健康度
    },
    "monitoring_levels": {         # 监控水平
        "upper_break": float,     # 上突破阈值
        "lower_break": float,     # 下突破阈值
        "upper_alert": float,     # 上预警阈值
        "lower_alert": float,     # 下预警阈值
    },
    "status": str,                 # 状态: monitoring/breakout/expired
    "expiry_time": timestamp,      # 过期时间
    "breakout_info": {             # 突破信息（突破时填充）
        "direction": str,         # 方向: long/short
        "breakout_time": timestamp,
        "breakout_bar": BarData,  # 突破K线
        "quality_score": int,     # 突破质量分
    }
}

# K线数据结构
BarData = {
    "timestamp": timestamp,       # K线时间
    "open": float,               # 开盘价
    "high": float,               # 最高价
    "low": float,                # 最低价
    "close": float,              # 收盘价
    "volume": float,             # 成交量
    "is_closed": bool,           # 是否已收盘
}
```

#### **关键参数总结表：**

| 参数 | 5分钟周期 | 15分钟周期 | 1分钟周期 | 说明 |
|------|-----------|------------|-----------|------|
| **ATR短期周期** | 20 | 14 | - | 短期波动率计算 |
| **ATR中期周期** | 100 | - | - | 中期波动率计算 |
| **布林带周期** | 20 | - | - | 布林带计算 |
| **价格范围短期** | 10 | 5 | - | 近期价格范围 |
| **价格范围中期** | 50 | 20 | - | 中期价格范围 |
| **成交量均线短** | 5 | - | 20 | 短期成交量平均 |
| **成交量均线长** | 20 | - | - | 长期成交量平均 |
| **压缩持续时间** | ≥4根 | - | - | 最小压缩时间 |
| **突破幅度** | - | - | 1.0% | 突破阈值幅度 |
| **突破预警幅度** | - | - | 0.5% | 提前预警幅度 |
| **实体强度阈值** | - | - | 0.2% | 最小实体大小 |
| **成交量爆发阈值** | - | - | 1.5倍 | 最小成交量放大 |
| **影线控制阈值** | - | - | 50% | 最大影线比率 |
| **突破质量阈值** | - | - | 60分 | 最小突破质量 |

## 三、异常情况处理

#### **1. 数据缺失处理**
```python
# 如果某个周期数据不足，采用降级策略
def handle_data_insufficiency(周期, 可用K线数):
    if 周期 == "5m" and 可用K线数 < 100:
        # 5分钟数据不足，临时使用3分钟线替代
        临时周期 = "3m"
        调整系数 = 5/3  # 周期调整系数
        
    elif 周期 == "15m" and 可用K线数 < 50:
        # 15分钟数据不足，使用5分钟线聚合
        临时周期 = "5m"
        聚合倍数 = 3   # 3根5分钟=15分钟
        
    else:
        # 数据充足，正常使用
        return True, None
```

#### **2. 市场异常过滤**
```python
# 在以下情况跳过压缩判断
def should_skip_compression_check():
    skip_conditions = [
        # 条件1：整体市场异常波动
        市场波动率指数 > 5.0,
        
        # 条件2：重大新闻发布时间前后30分钟
        is_news_period(时间戳, 前后分钟=30),
        
        # 条件3：交易所维护时间
        is_exchange_maintenance(时间戳),
        
        # 条件4：流动性过低时段
        当前成交量 < 24小时平均成交量 * 0.3,
        
        # 条件5：买卖价差过大
        当前买卖价差 > 平均价差 * 3.0,
    ]
    
    return any(skip_conditions)
```

#### 四、性能优化建议

#### **计算频率优化：**
```
5分钟周期：每5分钟计算一次（K线结束时）
15分钟周期：每15分钟计算一次（K线结束时）
1分钟周期：实时计算（每1分钟或tick级）
```

#### **缓存策略：**
```python
# 缓存计算结果，避免重复计算
计算缓存 = {
    "ATR_5m": {timestamp: value},     # 5分钟ATR缓存
    "BB_5m": {timestamp: value},      # 5分钟布林带缓存
    "Compression_Events": [],         # 压缩事件列表
    "Breakout_Signals": [],           # 突破信号列表
}

# 缓存有效期
缓存有效期 = {
    "ATR": 300,      # 5分钟
    "MA": 300,       # 5分钟
    "Compression": 600,  # 10分钟
}
```
